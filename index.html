<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>GreatPatrickStar</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="GreatPatrickStar">
<meta property="og:url" content="https://greatpatrickstar.github.io/index.html">
<meta property="og:site_name" content="GreatPatrickStar">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="GreatPatrickStar">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="GreatPatrickStar" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">GreatPatrickStar</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://greatpatrickstar.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-TCP的几个状态" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/21/TCP%E7%9A%84%E5%87%A0%E4%B8%AA%E7%8A%B6%E6%80%81/" class="article-date">
  <time class="dt-published" datetime="2022-06-21T09:19:15.000Z" itemprop="datePublished">2022-06-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/06/21/TCP%E7%9A%84%E5%87%A0%E4%B8%AA%E7%8A%B6%E6%80%81/">TCP的几个状态</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>TCP:SYN ACK FIN RST PSH URG简析</p>
<p>URG:Urget pointer is valid (紧急指针字段值有效)</p>
<p><strong>SYN: 表示建立连接</strong></p>
<p><strong>FIN: 表示关闭连接</strong></p>
<p><strong>ACK: 表示响应</strong></p>
<p><strong>PSH: 表示有 DATA数据传输</strong></p>
<p><strong>RST: 表示连接重置。</strong></p>
        
          <p class="article-more-link">
            <a href="/2022/06/21/TCP%E7%9A%84%E5%87%A0%E4%B8%AA%E7%8A%B6%E6%80%81/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://greatpatrickstar.github.io/2022/06/21/TCP%E7%9A%84%E5%87%A0%E4%B8%AA%E7%8A%B6%E6%80%81/" data-id="cl4nylyb300047ow38sf9dqba" data-title="TCP的几个状态" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-ensp" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/21/ensp/" class="article-date">
  <time class="dt-published" datetime="2022-06-21T08:01:22.000Z" itemprop="datePublished">2022-06-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/06/21/ensp/">ensp</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>eNSP</p>
<p>router</p>
<p>system-view sys快捷命令</p>
<p>进入端口 interface Ethernet0&#x2F;0&#x2F;0</p>
<p>ip address 1.1.1.1 24</p>
<p>display ip routing-table</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://greatpatrickstar.github.io/2022/06/21/ensp/" data-id="cl4nylyau00007ow3h619e0zr" data-title="ensp" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-IP地址的分类：A、B、C、D、E五类IP地址是如何划分的" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/21/IP%E5%9C%B0%E5%9D%80%E7%9A%84%E5%88%86%E7%B1%BB%EF%BC%9AA%E3%80%81B%E3%80%81C%E3%80%81D%E3%80%81E%E4%BA%94%E7%B1%BBIP%E5%9C%B0%E5%9D%80%E6%98%AF%E5%A6%82%E4%BD%95%E5%88%92%E5%88%86%E7%9A%84/" class="article-date">
  <time class="dt-published" datetime="2022-06-21T06:47:44.000Z" itemprop="datePublished">2022-06-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/06/21/IP%E5%9C%B0%E5%9D%80%E7%9A%84%E5%88%86%E7%B1%BB%EF%BC%9AA%E3%80%81B%E3%80%81C%E3%80%81D%E3%80%81E%E4%BA%94%E7%B1%BBIP%E5%9C%B0%E5%9D%80%E6%98%AF%E5%A6%82%E4%BD%95%E5%88%92%E5%88%86%E7%9A%84/">IP地址的分类：A、B、C、D、E五类IP地址是如何划分的</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>现在的IP网络使用32位地址，以点分十进制表示，如172.16.0.0。地址格式为：IP地址&#x3D;网络地址+主机地址 或 IP地址&#x3D;主机地址+子网地址+主机地址,需要的朋友可以参考下。</p>
        
          <p class="article-more-link">
            <a href="/2022/06/21/IP%E5%9C%B0%E5%9D%80%E7%9A%84%E5%88%86%E7%B1%BB%EF%BC%9AA%E3%80%81B%E3%80%81C%E3%80%81D%E3%80%81E%E4%BA%94%E7%B1%BBIP%E5%9C%B0%E5%9D%80%E6%98%AF%E5%A6%82%E4%BD%95%E5%88%92%E5%88%86%E7%9A%84/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://greatpatrickstar.github.io/2022/06/21/IP%E5%9C%B0%E5%9D%80%E7%9A%84%E5%88%86%E7%B1%BB%EF%BC%9AA%E3%80%81B%E3%80%81C%E3%80%81D%E3%80%81E%E4%BA%94%E7%B1%BBIP%E5%9C%B0%E5%9D%80%E6%98%AF%E5%A6%82%E4%BD%95%E5%88%92%E5%88%86%E7%9A%84/" data-id="cl4nylyb000017ow35btpb5le" data-title="IP地址的分类：A、B、C、D、E五类IP地址是如何划分的" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-hub-whatisit" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/21/hub-whatisit/" class="article-date">
  <time class="dt-published" datetime="2022-06-21T03:10:48.000Z" itemprop="datePublished">2022-06-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/06/21/hub-whatisit/">hub-whatisit</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="hub集线器"><a href="#hub集线器" class="headerlink" title="hub集线器"></a>hub集线器</h1>
        
          <p class="article-more-link">
            <a href="/2022/06/21/hub-whatisit/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://greatpatrickstar.github.io/2022/06/21/hub-whatisit/" data-id="cl4nylyb200037ow34pur8a7a" data-title="hub-whatisit" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-port-common" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/21/port-common/" class="article-date">
  <time class="dt-published" datetime="2022-06-21T02:39:45.000Z" itemprop="datePublished">2022-06-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/06/21/port-common/">port-common</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="常用端口号"><a href="#常用端口号" class="headerlink" title="常用端口号"></a>常用端口号</h1><p>wiki:</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/TCP/UDP%E7%AB%AF%E5%8F%A3%E5%88%97%E8%A1%A8">https://zh.wikipedia.org/wiki/TCP/UDP%E7%AB%AF%E5%8F%A3%E5%88%97%E8%A1%A8</a></p>
<p>计算机之间依照互联网<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E5%B1%82">传输层</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/TCP/IP%E5%8D%8F%E8%AE%AE">TCP&#x2F;IP协议</a>的协议通信，不同的协议都对应不同的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%80%9A%E8%A8%8A%E5%9F%A0">端口</a>。并且，利用数据报文的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AE">UDP</a>也不一定和<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE">TCP</a>采用相同的端口号码。以下为两种通信协议的端口列表链接：</p>
        
          <p class="article-more-link">
            <a href="/2022/06/21/port-common/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://greatpatrickstar.github.io/2022/06/21/port-common/" data-id="cl4nylybk00057ow392h33lp9" data-title="port-common" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-net-basic" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/21/net-basic/" class="article-date">
  <time class="dt-published" datetime="2022-06-21T02:24:00.000Z" itemprop="datePublished">2022-06-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/06/21/net-basic/">net-basic</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="网络基础知识-S计划"><a href="#网络基础知识-S计划" class="headerlink" title="网络基础知识-S计划"></a>网络基础知识-S计划</h1><h2 id="一-OSI七层模型"><a href="#一-OSI七层模型" class="headerlink" title="一.OSI七层模型"></a>一.OSI七层模型</h2><p>七层模型，亦称OSI（Open System Interconnection）参考模型，是参考模型是国际标准化组织（ISO）制定的一个用于计算机或通信系统间互联的标准体系。它是一个七层的、抽象的模型体，不仅包括一系列抽象的术语或概念，也包括具体的协议。</p>
        
          <p class="article-more-link">
            <a href="/2022/06/21/net-basic/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://greatpatrickstar.github.io/2022/06/21/net-basic/" data-id="cl4nylyb100027ow3c1qneut8" data-title="net-basic" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-windows-port-proxy" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/02/windows-port-proxy/" class="article-date">
  <time class="dt-published" datetime="2022-06-02T03:37:28.000Z" itemprop="datePublished">2022-06-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/06/02/windows-port-proxy/">windows port proxy</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="windows命令行实现端口转发"><a href="#windows命令行实现端口转发" class="headerlink" title="windows命令行实现端口转发"></a>windows命令行实现端口转发</h1><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/han-guang-xue/p/15723213.html">https://www.cnblogs.com/han-guang-xue/p/15723213.html</a></p>
<h2 id="两个不通的内网网段，-win10双网口，通过端口映射将一个内网的端口映射到其它不同内网网段的机器"><a href="#两个不通的内网网段，-win10双网口，通过端口映射将一个内网的端口映射到其它不同内网网段的机器" class="headerlink" title="两个不通的内网网段， win10双网口，通过端口映射将一个内网的端口映射到其它不同内网网段的机器"></a>两个不通的内网网段， win10双网口，通过端口映射将一个内网的端口映射到其它不同内网网段的机器</h2><ol>
<li>首先查看 win10 机器的端口占用情况</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -ano</span><br><span class="line">netstat -ano | findstr 22 #linux grep, win10 系统下使用 findstr， 查看某个端口占用情况</span><br></pre></td></tr></table></figure>

<p>2.现在137网段有一台机器 网口ip 192.168.137.206， 通过网线直连 win10的137网口， win10 双网口<br>ip设置为192.168.137.22， 192.168.0.18<br>\3. 使用命令 netsh</p>
<blockquote>
<p>该工具是个win10下很强大的工具，<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/windows-server/networking/technologies/netsh">详情查看官网</a></p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将本机的 22 端口映射到 192.168.137.206 22端口（linux远程端口）</span></span><br><span class="line">netsh interface portproxy add v4tov4 listenport=22 connectaddress=192.168.137.206 connectport=22</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示netsh相关配置</span></span><br><span class="line">netsh interface portproxy show all</span><br></pre></td></tr></table></figure>

<p>4.通过其他的机器ip：192.168.0.108远程登陆 <code>ssh root@192.168.137.206</code> 连接测试<br>5.记得关闭防火墙</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://greatpatrickstar.github.io/2022/06/02/windows-port-proxy/" data-id="cl3wgx2im000068w3ghtt2zhy" data-title="windows port proxy" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Annotation-Autowired-Resource" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/27/Annotation-Autowired-Resource/" class="article-date">
  <time class="dt-published" datetime="2022-05-27T00:39:32.000Z" itemprop="datePublished">2022-05-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/05/27/Annotation-Autowired-Resource/">Annotation-Autowired-Resource</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39989608/article/details/122662978">https://blog.csdn.net/qq_39989608/article/details/122662978</a></p>
<h1 id="Autowired-和-Resource的区别"><a href="#Autowired-和-Resource的区别" class="headerlink" title="@Autowired 和 @Resource的区别"></a>@Autowired 和 @Resource的区别</h1><p>1.@Autowired是Spring的，@Resource是javax包下的。</p>
<p>2.@Autowired默认按类型匹配，@Resource默认按名称匹配</p>
<p>3.@Autowired默认按类型匹配，</p>
<ul>
<li>spring容器中没有该类型的bean，报NoSuchBeanDefinitionException</li>
<li>有一个，注入找到的bean</li>
<li>spring容器中有多个该类型的bean。若@Autowired作用在字段上，用字段名去匹配，若匹配成功注入，否则报NoUniqueBeanDefinitionException。若@Autowired作用在setter方法或构造器方法上，用形参名去匹配，若匹配成功注入，否则报NoUniqueBeanDefinitionException。</li>
</ul>
<p>4.@Autowired和@Qualifier一同使用，@Qualifier指定bean的名称，当类型和名称都匹配时注入，否则报NoSuchBeanDefinitionException。@Autowired作用在setter或构造器方法时，@Qualifier需作用在方法的形参上。</p>
<p>5.@Resource默认按名称匹配，若作用在字段上用字段名，若作用在方法上用方法的形参名，若用名称匹配成功，注入。若用名称匹配失败，用类型匹配，有三种情况，没有、匹配到一个或多个。按类型没有匹配到，报NoSuchBeanDefinitionException；若匹配到一个，注入；若匹配到多个，报NoUniqueBeanDefinitionException。</p>
<p>6.@Resource</p>
<ul>
<li>指定name，按名称匹配。若用名称匹配成功，注入。若用名称匹配失败，报NoSuchBeanDefinitionException。</li>
<li>指定type，按类型匹配。有三种情况，没有、匹配到一个或多个。按类型没有匹配到，报NoSuchBeanDefinitionException；若匹配到一个，注入；若匹配到多个，报NoUniqueBeanDefinitionException。</li>
<li>指定name和type，名称和类型同时匹配，若匹配成功，注入，否则报NoSuchBeanDefinitionException。<br>（使用Spring容器的情况下，才报NoSuchBeanDefinitionException、NoUniqueBeanDefinitionException）</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://greatpatrickstar.github.io/2022/05/27/Annotation-Autowired-Resource/" data-id="cl3nq2tmu00006sw3375o4nqs" data-title="Annotation-Autowired-Resource" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-RequestBody-and-RequestParam" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/27/RequestBody-and-RequestParam/" class="article-date">
  <time class="dt-published" datetime="2022-05-27T00:30:46.000Z" itemprop="datePublished">2022-05-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/05/27/RequestBody-and-RequestParam/">RequestBody and RequestParam</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38407462/article/details/104486691">https://blog.csdn.net/qq_38407462/article/details/104486691</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/tiandi/p/15068325.html#:~:text=%E5%9C%A8%E5%90%8E%E7%AB%AF%E7%9A%84%E5%90%8C%E4%B8%80%E4%B8%AA%E6%8E%A5,()%E5%8F%AF%E4%BB%A5%E6%9C%89%E5%A4%9A%E4%B8%AA%E3%80%82">https://www.cnblogs.com/tiandi/p/15068325.html#:~:text&#x3D;%E5%9C%A8%E5%90%8E%E7%AB%AF%E7%9A%84%E5%90%8C%E4%B8%80%E4%B8%AA%E6%8E%A5,%28%29%E5%8F%AF%E4%BB%A5%E6%9C%89%E5%A4%9A%E4%B8%AA%E3%80%82</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_38004638/article/details/99655322">https://blog.csdn.net/weixin_38004638/article/details/99655322</a></p>
<h1 id="POST、GET、-RequestBody和-RequestParam区别"><a href="#POST、GET、-RequestBody和-RequestParam区别" class="headerlink" title="POST、GET、@RequestBody和@RequestParam区别"></a>POST、GET、@RequestBody和@RequestParam区别</h1><p>@RequestParam<br>注解@RequestParam接收的参数是来自HTTP请求体或请求url的QueryString中。</p>
<p>RequestParam可以接受简单类型的属性，也可以接受对象类型。</p>
<p>@RequestParam有三个配置参数：</p>
<p>required 表示是否必须，默认为 true，必须。<br>defaultValue 可设置请求参数的默认值。<br>value 为接收url的参数名（相当于key值）。<br>@RequestParam用来处理 Content-Type 为 application&#x2F;x-www-form-urlencoded 编码的内容，Content-Type默认为该属性。@RequestParam也可用于其它类型的请求，例如：POST、DELETE等请求。</p>
<p>所以在postman中，要选择body的类型为 x-www-form-urlencoded，这样在headers中就自动变为了 Content-Type : application&#x2F;x-www-form-urlencoded 编码格式。如下图所示：</p>
<p>但是这样不支持批量插入数据啊，如果改用 json 字符串来传值的话，类型设置为 application&#x2F;json，点击发送的话，会报错，后台接收不到值，为 null。</p>
<p>但可以入参后再转换，参考如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping(&quot;/ali-receive&quot;)</span><br><span class="line"> public void aliReceive(@RequestParam(&quot;message&quot;) String message) &#123;</span><br><span class="line">             ReceiveLog receiveLog = JSON.parseObject(message, ReceiveLog.class);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>解决Spring&#x2F;SpringBoot @RequestParam注解无法读取application&#x2F;json格式数据：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42536015/article/details/106906055">https://blog.csdn.net/weixin_42536015/article/details/106906055</a></p>
<p>@RequestParam 接受JSON的字符串：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40470612/article/details/104225419">https://blog.csdn.net/qq_40470612/article/details/104225419</a></p>
<p>不推荐使用@RequestParam接收application&#x2F;json，这时候就需要使用到@RequestBody。</p>
<p>@RequestBody</p>
<p>注解@RequestBody接收的参数是来自requestBody中，即请求体。一般用于处理非 Content-Type: application&#x2F;x-www-form-urlencoded编码格式的数据，比如：application&#x2F;json、application&#x2F;xml等类型的数据。</p>
<p>就application&#x2F;json类型的数据而言，使用注解@RequestBody可以将body里面所有的json数据传到后端，后端再进行解析。</p>
<p>GET请求中，因为没有HttpEntity，所以@RequestBody并不适用。</p>
<p>POST请求中，通过HttpEntity传递的参数，必须要在请求头中声明数据的类型Content-Type，SpringMVC通过使用</p>
<p>HandlerAdapter 配置的HttpMessageConverters来解析HttpEntity中的数据，然后绑定到相应的bean上。</p>
<p>向表中批量插入数据</p>
<p>举个批量插入数据的例子，Controller层的写法如下图所示：</p>
<p>由于@RequestBody可用来处理 Content-Type 为 application&#x2F;json 编码的内容，所以在postman中，选择body的类型为row -&gt; JSON(application&#x2F;json)，这样在 Headers 中也会自动变为 Content-Type : application&#x2F;json 编码格式。body内的数据如下图所示：</p>
<p>批量向表中插入两条数据，这里的 saveBatchNovel()方法已经封装了 JPA的 saveAll() 方法。body 里面的 json 语句的 key 值要与后端实体类的属性一一对应。</p>
<p>注意：前端使用$.ajax的话，一定要指定 contentType: “application&#x2F;json;charset&#x3D;utf-8;”，默认为 application&#x2F;x-www-form-urlencoded。</p>
<p>后端解析json数据</p>
<p>上述示例是传递到实体类中的具体写法，那么如果传递到非实体类中，body里面的json数据需要怎么解析呢？我们再来看下面这个例子：</p>
<p>在body中，我们还是输入上面的json数据，根据分析，上面的json数据是一个List数组内嵌套着map对象，那么在后台的接收形式可写为 List&lt;Map&lt;String, String&gt;&gt;，具体代码如下图所示：</p>
<p>postman请求：</p>
<p>控制台输出：</p>
<p>得出结论，通过@RequestBody可以解析Body中json格式的数据。</p>
<p>POST请求时<br>@RequestBody –&gt; JSON字符串部分</p>
<p>@RequestParam –&gt; 请求参数部分</p>
<p>application&#x2F;json格局图</p>
<p>form-data、x-www-form-urlencoded格局图</p>
<p>1、从content-type方面总结：<br>① form-data、x-www-form-urlencoded：不可以用@RequestBody；可以用@RequestParam。见postman的格局，这两种方式的时候没有json字符串部分。</p>
<p>② application&#x2F;json：json字符串部分可以用@RequestBody；url中的?后面参数可以用@RequestParam。见postman的格局</p>
<p>2、从两种注解方式总结：<br>@RequestBody</p>
<p>(@RequestBody Map map)<br>(@RequestBody Object object)<br>application&#x2F;json时候可用<br>form-data、x-www-form-urlencoded时候不可用<br>@RequestParam</p>
<p>(@RequestParam Map map)<br>application&#x2F;json时候，json字符串部分不可用，url中的?后面添加参数即可用，form-data、x-www-form-urlencoded时候可用，但是要将Headers里的Content-Type删掉<br>(@RequestParam String waterEleId,@RequestParam String enterpriseName)<br>application&#x2F;json时候，json字符串部分不可用，url中的?后面添加参数即可用<br>form-data、x-www-form-urlencoded时候可用，且参数可以没有顺序（即前端传过来的参数或者url中的参数顺序不必和后台接口中的参数顺序一致，只要字段名相同就可以），但是要将Headers里的Content-Type删掉<br>(@RequestParam Object object)<br>不管application&#x2F;json、form-data、x-www-form-urlencoded都不可用<br>既不是@RequestBody也不是@RequestParam，没有指定参数哪种接收方式</p>
<p>(Map map)<br>(Object object)<br>application&#x2F;json时候：json字符串部分不可用，url中的?后面添加参数不可用。<br>因为没有指定，它也不知道到底是用json字符串部分还是?后面添加参数部分，所以干脆都不可以用<br>form-data、x-www-form-urlencoded时都不可用，见图二</p>
<p>(HttpServletRequest request)<br>application&#x2F;json不可用<br>form-data、x-www-form-urlencoded时可用<br>GET请求<br>@RequestBody</p>
<p>RequestBody – Map &#x2F; Object<br>GET请求中不可以使用@RequestBody<br>@RequestParam</p>
<p>(@RequestParam Map map)<br>在url中的?后面添加参数即可使用<br>(@RequestParam String waterEleId,@RequestParam String enterpriseName)<br>在url中的?后面添加参数即可使用<br>(@RequestParam Object object)<br>GET请求中不可以使用<br>当使用GET请求时，通过postman添加?后面的参数，不用在url中自己一个一个拼，点击Params，在下面key-value中输入就自动拼接到url中</p>
<p>举栗子<br>上传文件，包含了图中圈出来的两部分</p>
<p>如果这样，没有@RequestParam，那么url?后的参数就拿不到</p>
<p>@RequestMapping(value &#x3D; “&#x2F;leadingIn”, method &#x3D; RequestMethod.POST)<br>    public ResponseObj<Boolean> leadingIn(Map formData,<br>                                          HttpServletRequest request,<br>                                          Map&lt;String, InputStream&gt; files) {<br>}<br>如果control中这样接收，本来想formData只接收url?后的参数，结果将{ “retCode”: null, “data”: true }这部分内容也拿到了，真实意外之喜。字符串这部分内容还可以从request中取到，见下面完整方法。</p>
<p>@RequestMapping(value &#x3D; “&#x2F;leadingIn”, method &#x3D; RequestMethod.POST)<br>    public ResponseObj<Boolean> leadingIn(@RequestParam Map formData,<br>                                          HttpServletRequest request,<br>                                          Map&lt;String, InputStream&gt; files) {<br>}<br>完整方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">    /**</span><br><span class="line">     * 导入</span><br><span class="line">     */</span><br><span class="line">    @RequestMapping(value = &quot;/leadingIn&quot;, method = RequestMethod.POST)</span><br><span class="line">    public ResponseObj&lt;Boolean&gt; leadingIn(@RequestParam Map formData,</span><br><span class="line">                                          HttpServletRequest request,</span><br><span class="line">                                          Map&lt;String, InputStream&gt; files) &#123;</span><br><span class="line">        //测试</span><br><span class="line">        try &#123;</span><br><span class="line">            MultipartHttpServletRequest mulRequest = (MultipartHttpServletRequest) request;</span><br><span class="line">            Set&lt;Map.Entry&lt;String, MultipartFile&gt;&gt; set = mulRequest.getFileMap().entrySet();</span><br><span class="line">            Map&lt;String, InputStream&gt; listFile = new LinkedHashMap&lt;&gt;();</span><br><span class="line">            System.out.println(&quot;个数&quot; + set.size());</span><br><span class="line">            for (Map.Entry&lt;String, MultipartFile&gt; each : set) &#123;</span><br><span class="line">                String fileName = each.getKey();</span><br><span class="line">                MultipartFile file = each.getValue();</span><br><span class="line">                //这里需要上传FTP</span><br><span class="line">                try &#123;</span><br><span class="line">                    listFile.put(fileName, file.getInputStream());</span><br><span class="line">                &#125; catch (Exception ex) &#123;</span><br><span class="line">                    return new ResponseObj&lt;&gt;(false, null);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">     </span><br><span class="line">            String formjson = mulRequest.getParameter(&quot;content&quot;);</span><br><span class="line">            ObjectMapper mapper = new ObjectMapper();</span><br><span class="line">            mapper.setVisibility(PropertyAccessor.FIELD, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">            mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);</span><br><span class="line"></span><br><span class="line">//            boolean result = iInstallWorkOrder.upLoadFile(listFile);</span><br><span class="line">            boolean result = true;</span><br><span class="line"></span><br><span class="line">            return new ResponseObj&lt;&gt;(result, null);</span><br><span class="line">        &#125; catch (Exception ex) &#123;</span><br><span class="line">            System.out.println(ex.toString());</span><br><span class="line">            return new ResponseObj&lt;&gt;(false, null);</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>按F12看一下Network里对应请求：</p>
<p>使用@RequestParam：Content-Type为application&#x2F;x-www-form-urlencoded，参数在FormData中</p>
<p>使用@RequestBody：Content-Type为application&#x2F;json，参数在Request PayLoad中</p>
<p>总结 •在GET请求中，不能使用@RequestBody。 •在POST请求，可以使用@RequestBody和@RequestParam，但是如果使用@RequestBody，对于参数转化的配置必须统一。<br>可以使用多个@RequestParam获取数据，@RequestBody不可以 举个例子，在SpringMVC配置了HttpMessageConverters处理栈中，指定json转化的格式，如Date转成‘yyyy-MM-dd’,则参数接收对象包含的字段如果是Date类型，就只能让客户端传递年月日的格式，不能传时分秒。因为不同的接口，它的参数可能对时间参数有不同的格式要求，所以这样做会让客户端调用同事对参数的格式有点困惑，所以说扩展性不高。 如果使用@RequestParam来接受参数，可以在接受参数的model中设置@DateFormat指定所需要接受时间参数的格式。 另外，使用@RequestBody接受的参数是不会被Servlet转化统一放在request对象的Param参数集中，@RequestParam是可以的。</p>
<p>另外，还有一种应用场景，接口规范为resultful风格时，举个例子：如果要获取某个id下此条问题答案的查询次数的话，则后台就需要动态获取参数，其注解为@PathVariable，并且requestMapping中的value应为value&#x3D;”&#x2F;{id}&#x2F;queryNum”，截图如下：</p>
<p>参考：</p>
<p>@RequestParam @RequestBody @PathVariable 等参数绑定注解详解</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/walkerjong/article/details/7946109">https://blog.csdn.net/walkerjong/article/details/7946109</a></p>
<p><a target="_blank" rel="noopener" href="https://my.oschina.net/u/3372000/blog/906217">https://my.oschina.net/u/3372000/blog/906217</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/4981911d5e15">https://www.jianshu.com/p/4981911d5e15</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1414464">https://cloud.tencent.com/developer/article/1414464</a><br>————————————————<br>版权声明：本文为CSDN博主「陈晨辰呀」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_38004638/article/details/99655322">https://blog.csdn.net/weixin_38004638/article/details/99655322</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://greatpatrickstar.github.io/2022/05/27/RequestBody-and-RequestParam/" data-id="cl3nq2tn000026sw38veq6ycm" data-title="RequestBody and RequestParam" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-wsl-autostart-service" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/26/wsl-autostart-service/" class="article-date">
  <time class="dt-published" datetime="2022-05-26T03:35:44.000Z" itemprop="datePublished">2022-05-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/05/26/wsl-autostart-service/">wsl autostart service</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lazycn/p/16085713.html">https://www.cnblogs.com/lazycn/p/16085713.html</a></p>
</blockquote>
<h1 id="WSL-WSL2-服务自启动-x2F-WSL-ssh-开机自启动"><a href="#WSL-WSL2-服务自启动-x2F-WSL-ssh-开机自启动" class="headerlink" title="WSL WSL2 服务自启动 &#x2F; WSL ssh 开机自启动"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lazycn/p/16085713.html">WSL WSL2 服务自启动 &#x2F; WSL ssh 开机自启动</a></h1><p>网上有很多方法，要么过于复杂，要么已经过时，下面这个方法是最简洁，最有效的方法</p>
<p>我的环境是windows10，Ubuntu 20.04.4 LTS，WSL发行版的名字是Ubuntu</p>
<p>进入任意WSL发行版中，创建并编辑文件：<em>vim &#x2F;etc&#x2F;init.wsl</em></p>
<p>#!&#x2F;bin&#x2F;sh</p>
<p>&#x2F;etc&#x2F;init.d&#x2F;cron $1</p>
<p>&#x2F;etc&#x2F;init.d&#x2F;ssh $1</p>
<p>&#x2F;etc&#x2F;init.d&#x2F;supervisor $1</p>
<p>里面调用了我们希望启动的三个服务的启动脚本，设置*&#x2F;etc&#x2F;init.wsl<em>权限</em>777*，这时候可以通过：</p>
<p>sudo &#x2F;etc&#x2F;init.wsl [start|stop|restart]</p>
<p>来启停我们需要的服务，在Windows中，<strong>开始</strong> <strong>&gt;</strong> <strong>运行</strong>，输入：</p>
<p>shell:startup</p>
<p>在打开的文件夹中按照你WSL使用的Linux发行版创建启动脚本，比如创建的<em>Debian.vbs</em>文件：</p>
<p>Set ws &#x3D; CreateObject(“Wscript.Shell”)</p>
<p>ws.run “wsl -d debian -u root &#x2F;etc&#x2F;init.wsl start”, vbhide</p>
<p>这个脚本就会在你登陆的时候自动在名字为<em>debian</em>的wsl发行版中执行*&#x2F;etc&#x2F;init.wsl*启动我们的服务了，</p>
<p>而如果你不知道自己的 WSL 发行版叫做什么名字，可以用 “wsl -l” 来查看。不管你用最初的 bash (ubuntu 16.04) 还是商店里下载的 debian&#x2F;ubuntu1804 都能顺利启动服务了。</p>
<p>如果你用的是Ubuntu-18.04 LTS的发行版，那么修改上面脚本里的<em>debian</em>为<em>Ubuntu-18.04</em>，并创建<em>ubuntu1804.vbs</em>：</p>
<p>Set ws &#x3D; CreateObject(“Wscript.Shell”)</p>
<p>ws.run “wsl -d Ubuntu-18.04 -u root &#x2F;etc&#x2F;init.wsl start”, vbhide</p>
<p>而如果你不知道自己的WSL发行版叫做什么名字，可以用<em>wsl -l</em>来查看。</p>
<p>WSL中有很多有用的服务，你可以按需删改*&#x2F;etc&#x2F;init.wsl<em>，但没必要塞很多东西进去影响你的启动速度，比如</em>mysql&#x2F;mongodb*这些重度服务，可以需要的时候再启动，用完就停了。</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/47733615">https://zhuanlan.zhihu.com/p/47733615</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/sinicheveen/p/13866881.html">https://www.cnblogs.com/sinicheveen/p/13866881.html</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/toopoo/article/details/85733566">https://blog.csdn.net/toopoo/article/details/85733566</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://greatpatrickstar.github.io/2022/05/26/wsl-autostart-service/" data-id="cl3nq2tn400046sw388fn7xy1" data-title="wsl autostart service" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/06/21/TCP%E7%9A%84%E5%87%A0%E4%B8%AA%E7%8A%B6%E6%80%81/">TCP的几个状态</a>
          </li>
        
          <li>
            <a href="/2022/06/21/ensp/">ensp</a>
          </li>
        
          <li>
            <a href="/2022/06/21/IP%E5%9C%B0%E5%9D%80%E7%9A%84%E5%88%86%E7%B1%BB%EF%BC%9AA%E3%80%81B%E3%80%81C%E3%80%81D%E3%80%81E%E4%BA%94%E7%B1%BBIP%E5%9C%B0%E5%9D%80%E6%98%AF%E5%A6%82%E4%BD%95%E5%88%92%E5%88%86%E7%9A%84/">IP地址的分类：A、B、C、D、E五类IP地址是如何划分的</a>
          </li>
        
          <li>
            <a href="/2022/06/21/hub-whatisit/">hub-whatisit</a>
          </li>
        
          <li>
            <a href="/2022/06/21/port-common/">port-common</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 GreatPatrickStar<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>